/*****************************************************************************

    plik  : bmp_writer.c
    autor : Michal Kolodziejski (2:480/112.10)
    data  : 2025.09.30
    copyright  : PTODT <https://ptodt.org.pl>

    opis  : implementacja funkcji zapisu plików BMP

    licencja : MIT
*****************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include "bmp_writer.h"
#include "bmp_palette.h"
#include "version.h"

/**
 * @brief Zapisuje sekcję copyright do pliku BMP
 * 
 * @details Funkcja zapisuje niestandardową sekcję copyright po nagłówku BMP,
 * ale przed danymi obrazu. Sekcja zawiera informacje o wersji, dacie budowania
 * i prawach autorskich. Maksymalnie 256 bajtów.
 * 
 * @param file Wskaźnik do otwartego pliku BMP
 * @return 1 w przypadku sukcesu, 0 w przypadku błędu
 */
static int write_bmp_copyright_section(FILE* file) {
    if (!file) return 0;
    
    // Nagłówek sekcji copyright (4 bajty)
    uchar section_header[4] = {0x43, 0x4F, 0x50, 0x59}; // "COPY"
    
    // Długość sekcji (4 bajty) - maksymalnie 256 bajtów
    dword section_length = 0;
    
    // Tworzenie tekstu copyright
    char copyright_text[256] = {0};
    time_t now = time(NULL);
    struct tm* tm_info = localtime(&now);
    char date_str[32];
    strftime(date_str, sizeof(date_str), "%Y-%m-%d %H:%M:%S", tm_info);
    
    snprintf(copyright_text, sizeof(copyright_text),
        "Generated by BMP to xbpp Array Converter %s (%s)\n"
        "Copyright (c) %s %s\n"
        "https://ptodt.org.pl\n"
        "Build time: %s\n"
        "-=# Didn't like it? Mind you own values #=-\n",
        VERSION_STRING, date_str,
        COPYRIGHT_STRING, VERSION_DATE,
        BUILD_DATETIME
    );
    
    // Oblicz rzeczywistą długość tekstu
    section_length = (dword)strlen(copyright_text);
    if (section_length > 248) section_length = 248; // Zostaw miejsce na nagłówek i długość
    
    // Zapisz nagłówek sekcji
    if (fwrite(section_header, 1, 4, file) != 4) return 0;
    
    // Zapisz długość sekcji
    if (fwrite(&section_length, 1, 4, file) != 4) return 0;
    
    // Zapisz tekst copyright
    if (fwrite(copyright_text, 1, section_length, file) != section_length) return 0;
    
    // Wypełnij do 256 bajtów zerami
    uchar padding[256] = {0};
    int padding_size = 256 - 8 - section_length;
    if (padding_size > 0) {
        if (fwrite(padding, 1, padding_size, file) != padding_size) return 0;
    }
    
    return 1;
}

/**
 * @brief Generuje plik BMP 1bpp z spakowanych danych
 * 
 * @details Funkcja tworzy plik BMP w formacie 1bpp (1 bit na piksel) z danych
 * spakowanych w bajtach. Obsługuje różne palety kolorów, skanowanie poziome/pionowe
 * i generuje pełny plik BMP z nagłówkami, paletą kolorów i danymi obrazu.
 * 
 * @param packed_data Wskaźnik do spakowanych danych 1bpp (8 pikseli na bajt)
 * @param preview_ctx Wskaźnik do struktury PreviewContext z parametrami
 * 
 * @return 1 w przypadku sukcesu, 0 w przypadku błędu
 * 
 * @note Generuje pełny plik BMP z nagłówkami i paletą
 * @note Obsługuje wyrównanie wierszy do granicy 4-bajtowej
 * @note Konwertuje dane kolumnowe na wierszowe dla podglądu
 * @note Używa palety 2-kolorowej (0=czarny, 1=biały)
 * 
 * @example
 * ```c
 * PreviewContext ctx = {64, 32, "preview.bmp", PALETTE_BW, NULL, NULL, 1};
 * uchar data[256];  // 64*32/8 = 256 bajtów
 * 
 * if (generate_1bpp_bmp(data, &ctx)) {
 *     // Plik BMP został wygenerowany pomyślnie
 * }
 * ```
 */
int generate_1bpp_bmp(uchar* packed_data, PreviewContext* preview_ctx) {
    int width = preview_ctx->width;
    int height = preview_ctx->height;
    const char* output_path = preview_ctx->output_path;
    int palette_variant = preview_ctx->palette_variant;
    uchar* custom_first = preview_ctx->custom_first;
    uchar* custom_last = preview_ctx->custom_last;
    int scan_direction = preview_ctx->scan_direction;
    FILE* file = fopen(output_path, "wb");
    if (!file) {
        return 0;
    }
    
    // Oblicz rozmiar wiersza z dopełnieniem (musi być wielokrotnością 4)
    int row_size = ((width + 7) / 8 + 3) & ~3; // Zaokrąglij w górę do wielokrotności 4
    int data_size = row_size * height;
    
    // Nagłówek BMP
    BMPHeader bmp_header = {
        .signature = {0x42, 0x4D}, // "BM"
        .file_size = 0,            // Zostanie wypełnione
        .reserved = 0,
        .data_offset = BMP_1BPP_DATA_OFFSET
    };
    
    // Oblicz rozmiar pliku (z sekcją copyright)
    unsigned int file_size = BMP_HEADER_SIZE + BMP_INFO_HEADER_SIZE + BMP_1BPP_PALETTE_SIZE + BMP_COPYRIGHT_SECTION_SIZE + data_size;
    bmp_header.file_size = file_size;
    
    // Nagłówek informacyjny BMP
    BMPInfoHeader info_header = {
        .header_size = BMP_INFO_HEADER_SIZE,
        .width = width,
        .height = height,
        .planes = 1,
        .bits_per_pixel = 1,
        .compression = BMP_COMPRESSION_NONE,
        .image_size = data_size,
        .x_pixels_per_meter = 0,
        .y_pixels_per_meter = 0,
        .colors_used = 2,
        .colors_important = 0
    };
    
    // Paleta kolorów - wybrana wariant
    BMPColorEntry palette[2];
    PaletteContext palette_context = {palette_variant, 2, {custom_first[0], custom_first[1], custom_first[2]}, {custom_last[0], custom_last[1], custom_last[2]}};
    generate_palette(palette, &palette_context);
    
    // Zapisz nagłówek BMP
    fwrite(&bmp_header, 1, sizeof(BMPHeader), file);
    fwrite(&info_header, 1, sizeof(BMPInfoHeader), file);
    fwrite(palette, 1, sizeof(palette), file);
    
    // Zapisz sekcję copyright
    if (!write_bmp_copyright_section(file)) {
        fclose(file);
        return 0;
    }
    
    // Zapisz dane obrazu (od dołu do góry)
    if (scan_direction) {
        // Skanowanie poziome - dane są w formacie wierszowym
        for (int y = height - 1; y >= 0; y--) {
            fwrite(packed_data + (y * ((width + 7) / 8)), 1, (width + 7) / 8, file);
            // Dodaj dopełnienie wiersza
            int padding = row_size - ((width + 7) / 8);
            for (int p = 0; p < padding; p++) {
                fputc(0x00, file);
            }
        }
    } else {
        // Skanowanie pionowe - dane są w formacie kolumnowym, musimy je przekonwertować
        uchar* row_data = malloc((width + 7) / 8);
        for (int y = height - 1; y >= 0; y--) {
            // Wyzeruj wiersz
            memset(row_data, 0, (width + 7) / 8);
            
            // Skopiuj piksele z kolumn do wiersza
            for (int x = 0; x < width; x++) {
                int col_bytes = (height + 7) / 8;
                int byte_index = x * col_bytes + (y / 8);
                int bit_index = y % 8;
                
                if (byte_index < (width * col_bytes)) {
                    uchar pixel_bit = (packed_data[byte_index] >> bit_index) & 1;
                    if (pixel_bit) {
                        int row_byte = x / 8;
                        int row_bit = 7 - (x % 8);
                        row_data[row_byte] |= (1 << row_bit);
                    }
                }
            }
            
            fwrite(row_data, 1, (width + 7) / 8, file);
            // Dodaj dopełnienie wiersza
            int padding = row_size - ((width + 7) / 8);
            for (int p = 0; p < padding; p++) {
                fputc(0x00, file);
            }
        }
        free(row_data);
    }
    
    fclose(file);
    return 1;
}

/**
 * @brief Generuje plik BMP 4bpp z spakowanych danych
 * 
 * @details Funkcja tworzy plik BMP w formacie 4bpp (4 bity na piksel) z danych
 * spakowanych w bajtach. Obsługuje różne palety kolorów, skanowanie poziome/pionowe
 * i generuje pełny plik BMP z nagłówkami, paletą kolorów i danymi obrazu.
 * 
 * @param packed_data Wskaźnik do spakowanych danych 4bpp (2 piksele na bajt)
 * @param preview_ctx Wskaźnik do struktury PreviewContext z parametrami
 * 
 * @return 1 w przypadku sukcesu, 0 w przypadku błędu
 * 
 * @note Generuje pełny plik BMP z nagłówkami i paletą 16-kolorową
 * @note Obsługuje wyrównanie wierszy do granicy 4-bajtowej
 * @note Konwertuje dane kolumnowe na wierszowe dla podglądu
 * @note Używa palety 16-kolorowej z interpolacją liniową
 * 
 * @example
 * ```c
 * PreviewContext ctx = {64, 32, "preview.bmp", PALETTE_BW, NULL, NULL, 1};
 * uchar data[512];  // 64*32/2 = 1024 bajtów
 * 
 * if (generate_4bpp_bmp(data, &ctx)) {
 *     // Plik BMP został wygenerowany pomyślnie
 * }
 * ```
 */
int generate_4bpp_bmp(uchar* packed_data, PreviewContext* preview_ctx) {
    int width = preview_ctx->width;
    int height = preview_ctx->height;
    const char* output_path = preview_ctx->output_path;
    int palette_variant = preview_ctx->palette_variant;
    uchar* custom_first = preview_ctx->custom_first;
    uchar* custom_last = preview_ctx->custom_last;
    int scan_direction = preview_ctx->scan_direction;
    FILE* file = fopen(output_path, "wb");
    if (!file) {
        return 0;
    }
    
    // Oblicz rozmiar wiersza z dopełnieniem (musi być wielokrotnością 4)
    int row_size = ((width + 1) / 2 + 3) & ~3; // Zaokrąglij w górę do wielokrotności 4
    int data_size = row_size * height;
    
    // Nagłówek BMP
    BMPHeader bmp_header = {
        .signature = {0x42, 0x4D}, // "BM"
        .file_size = 0,            // Zostanie wypełnione
        .reserved = 0,
        .data_offset = BMP_4BPP_DATA_OFFSET
    };
    
    // Oblicz rozmiar pliku (z sekcją copyright)
    unsigned int file_size = BMP_HEADER_SIZE + BMP_INFO_HEADER_SIZE + BMP_4BPP_PALETTE_SIZE + BMP_COPYRIGHT_SECTION_SIZE + data_size;
    bmp_header.file_size = file_size;
    
    // Nagłówek informacyjny BMP
    BMPInfoHeader info_header = {
        .header_size = BMP_INFO_HEADER_SIZE,
        .width = width,
        .height = height,
        .planes = 1,
        .bits_per_pixel = 4,
        .compression = BMP_COMPRESSION_NONE,
        .image_size = data_size,
        .x_pixels_per_meter = 0,
        .y_pixels_per_meter = 0,
        .colors_used = 16,
        .colors_important = 0
    };
    
    // Paleta kolorów (16 odcieni)
    BMPColorEntry palette[16];
    PaletteContext palette_context = {palette_variant, 16, {custom_first[0], custom_first[1], custom_first[2]}, {custom_last[0], custom_last[1], custom_last[2]}};
    generate_palette(palette, &palette_context);
    
    // Zapisz nagłówek BMP
    fwrite(&bmp_header, 1, sizeof(BMPHeader), file);
    fwrite(&info_header, 1, sizeof(BMPInfoHeader), file);
    fwrite(palette, 1, sizeof(palette), file);
    
    // Zapisz sekcję copyright
    if (!write_bmp_copyright_section(file)) {
        fclose(file);
        return 0;
    }
    
    // Zapisz dane obrazu (od dołu do góry)
    if (scan_direction) {
        // Skanowanie poziome - dane są w formacie wierszowym
        for (int y = height - 1; y >= 0; y--) {
            fwrite(packed_data + (y * ((width + 1) / 2)), 1, (width + 1) / 2, file);
            // Dodaj dopełnienie wiersza
            int padding = row_size - ((width + 1) / 2);
            for (int p = 0; p < padding; p++) {
                fputc(0x00, file);
            }
        }
    } else {
        // Skanowanie pionowe - dane są w formacie kolumnowym, musimy je przekonwertować
        uchar* row_data = malloc((width + 1) / 2);
        for (int y = height - 1; y >= 0; y--) {
            // Wyzeruj wiersz
            memset(row_data, 0, (width + 1) / 2);
            
            // Skopiuj piksele z kolumn do wiersza
            for (int x = 0; x < width; x += 2) {
                int col_bytes = (height + 1) / 2;
                int byte_index = (x / 2) * col_bytes + (y / 2);
                
                if (byte_index < ((width / 2) * col_bytes)) {
                    uchar packed_byte = packed_data[byte_index];
                    uchar pixel1, pixel2;
                    
                    // W formacie pionowym, każdy bajt zawiera 2 piksele z tej samej kolumny
                    if (y % 2 == 0) {
                        // Pierwszy piksel w parze
                        pixel1 = (packed_byte >> 4) & 0x0F;
                        pixel2 = packed_byte & 0x0F;
                    } else {
                        // Drugi piksel w parze
                        pixel1 = packed_byte & 0x0F;
                        pixel2 = (packed_byte >> 4) & 0x0F;
                    }
                    
                    // Zapisz piksele w wierszu
                    if (x + 1 < width) {
                        row_data[x / 2] = (pixel1 << 4) | pixel2;
                    } else {
                        row_data[x / 2] = (pixel1 << 4);
                    }
                }
            }
            
            fwrite(row_data, 1, (width + 1) / 2, file);
            // Dodaj dopełnienie wiersza
            int padding = row_size - ((width + 1) / 2);
            for (int p = 0; p < padding; p++) {
                fputc(0x00, file);
            }
        }
        free(row_data);
    }
    
    fclose(file);
    return 1;
}
